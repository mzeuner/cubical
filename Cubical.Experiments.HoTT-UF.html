<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Cubical.Experiments.HoTT-UF</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">{-

This is a HoTT-UF core library based on cubical type theory, where the
cubical machinery is hidden, using the HoTT Book terminology and
notation.

The point is that function extensionality, propositional truncation
and univalence compute (an example is given below).

For the moment, this requires the development version of Agda.

-}</a>

<a id="341" class="Symbol">{-#</a> <a id="345" class="Keyword">OPTIONS</a> <a id="353" class="Pragma">--exact-split</a> <a id="367" class="Pragma">--safe</a> <a id="374" class="Symbol">#-}</a>

<a id="379" class="Keyword">module</a> <a id="386" href="Cubical.Experiments.HoTT-UF.html" class="Module">Cubical.Experiments.HoTT-UF</a> <a id="414" class="Keyword">where</a>

<a id="421" class="Keyword">open</a> <a id="426" class="Keyword">import</a> <a id="433" href="Cubical.Core.Primitives.html" class="Module">Cubical.Core.Primitives</a> <a id="457" class="Keyword">hiding</a> <a id="464" class="Symbol">(</a> <a id="466" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">_≡_</a> <a id="470" class="Symbol">)</a>
<a id="472" class="Keyword">open</a> <a id="477" class="Keyword">import</a> <a id="484" href="Cubical.Core.Id.html" class="Module">Cubical.Core.Id</a> <a id="500" class="Keyword">public</a>

<a id="508" class="Keyword">open</a> <a id="513" class="Keyword">import</a> <a id="520" href="Cubical.Foundations.Id.html" class="Module">Cubical.Foundations.Id</a> <a id="543" class="Keyword">public</a>
     <a id="555" class="Keyword">using</a> <a id="561" class="Symbol">(</a> <a id="563" href="Cubical.Core.Id.html#1053" class="Function Operator">_≡_</a>            <a id="578" class="Comment">-- The identity type.</a>
           <a id="611" class="Symbol">;</a> <a id="613" href="Cubical.Foundations.Id.html#2078" class="Function">refl</a>           <a id="628" class="Comment">-- Unfortunately, pattern matching on refl is not available.</a>
           <a id="700" class="Symbol">;</a> <a id="702" href="Cubical.Foundations.Id.html#2240" class="Function">J</a>              <a id="717" class="Comment">-- Until it is, you have to use the induction principle J.</a>

           <a id="788" class="Symbol">;</a> <a id="790" href="Cubical.Foundations.Id.html#2671" class="Function">transport</a>      <a id="805" class="Comment">-- As in the HoTT Book.</a>
           <a id="840" class="Symbol">;</a> <a id="842" href="Cubical.Foundations.Id.html#2861" class="Function">ap</a>
           <a id="856" class="Symbol">;</a> <a id="858" href="Cubical.Foundations.Id.html#2967" class="Function Operator">_∙_</a>
           <a id="873" class="Symbol">;</a> <a id="875" href="Cubical.Foundations.Id.html#2787" class="Function Operator">_⁻¹</a>

           <a id="891" class="Symbol">;</a> <a id="893" href="Cubical.Foundations.Id.html#3090" class="Function Operator">_≡⟨_⟩_</a>         <a id="908" class="Comment">-- Standard equational reasoning.</a>
           <a id="953" class="Symbol">;</a> <a id="955" href="Cubical.Foundations.Id.html#3161" class="Function Operator">_∎</a>

           <a id="970" class="Symbol">;</a> <a id="972" href="Cubical.Foundations.Id.html#4090" class="Function">funExt</a>         <a id="987" class="Comment">-- Function extensionality</a>
                            <a id="1042" class="Comment">-- (can also be derived from univalence).</a>

           <a id="1096" class="Symbol">;</a> <a id="1098" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a>              <a id="1113" class="Comment">-- Sum type. Needed to define contractible types, equivalences</a>
           <a id="1187" class="Symbol">;</a> <a id="1189" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a>            <a id="1204" class="Comment">-- and univalence.</a>
           <a id="1234" class="Symbol">;</a> <a id="1236" href="Cubical.Foundations.Id.html#955" class="Field">pr₁</a>            <a id="1251" class="Comment">-- The eta rule is available.</a>
           <a id="1292" class="Symbol">;</a> <a id="1294" href="Cubical.Foundations.Id.html#1008" class="Field">pr₂</a>

           <a id="1310" class="Symbol">;</a> <a id="1312" href="Cubical.Foundations.Id.html#4448" class="Function">isProp</a>         <a id="1327" class="Comment">-- The usual notions of proposition, contractible type, set.</a>
           <a id="1399" class="Symbol">;</a> <a id="1401" href="Cubical.Foundations.Id.html#4384" class="Function">isContr</a>
           <a id="1420" class="Symbol">;</a> <a id="1422" href="Cubical.Foundations.Id.html#4503" class="Function">isSet</a>

           <a id="1440" class="Symbol">;</a> <a id="1442" href="Cubical.Foundations.Id.html#4572" class="Record">isEquiv</a>        <a id="1457" class="Comment">-- A map with contractible fibers</a>
                            <a id="1519" class="Comment">-- (Voevodsky&#39;s version of the notion).</a>
           <a id="1570" class="Symbol">;</a> <a id="1572" href="Cubical.Foundations.Id.html#4736" class="Function Operator">_≃_</a>            <a id="1587" class="Comment">-- The type of equivalences between two given types.</a>
           <a id="1651" class="Symbol">;</a> <a id="1653" href="Cubical.Foundations.Id.html#9158" class="Function">EquivContr</a>     <a id="1668" class="Comment">-- A formulation of univalence.</a>

           <a id="1712" class="Symbol">;</a> <a id="1714" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥_∥</a>             <a id="1730" class="Comment">-- Propositional truncation.</a>
           <a id="1770" class="Symbol">;</a> <a id="1772" href="Cubical.HITs.PropositionalTruncation.Base.html#287" class="InductiveConstructor Operator">∣_∣</a>             <a id="1788" class="Comment">-- Map into the propositional truncation.</a>
           <a id="1841" class="Symbol">;</a> <a id="1843" href="Cubical.Foundations.Id.html#9698" class="Function">∥∥-isProp</a>       <a id="1859" class="Comment">-- A truncated type is a proposition.</a>
           <a id="1908" class="Symbol">;</a> <a id="1910" href="Cubical.Foundations.Id.html#9777" class="Function">∥∥-recursion</a>    <a id="1926" class="Comment">-- Non-dependent elimination.</a>
           <a id="1967" class="Symbol">;</a> <a id="1969" href="Cubical.Foundations.Id.html#9927" class="Function">∥∥-induction</a>    <a id="1985" class="Comment">-- Dependent elimination.</a>
           <a id="2022" class="Symbol">)</a>

<a id="2025" class="Comment">{-

Here is an illustration of how function extensionality computes.

-}</a>

<a id="2099" class="Keyword">private</a>

  <a id="2110" class="Keyword">data</a> <a id="ℕ"></a><a id="2115" href="Cubical.Experiments.HoTT-UF.html#2115" class="Datatype">ℕ</a> <a id="2117" class="Symbol">:</a> <a id="2119" href="Agda.Primitive.html#326" class="Primitive">Type₀</a> <a id="2125" class="Keyword">where</a>
   <a id="ℕ.zero"></a><a id="2134" href="Cubical.Experiments.HoTT-UF.html#2134" class="InductiveConstructor">zero</a> <a id="2139" class="Symbol">:</a> <a id="2141" href="Cubical.Experiments.HoTT-UF.html#2115" class="Datatype">ℕ</a>
   <a id="ℕ.succ"></a><a id="2146" href="Cubical.Experiments.HoTT-UF.html#2146" class="InductiveConstructor">succ</a> <a id="2151" class="Symbol">:</a> <a id="2153" href="Cubical.Experiments.HoTT-UF.html#2115" class="Datatype">ℕ</a> <a id="2155" class="Symbol">→</a> <a id="2157" href="Cubical.Experiments.HoTT-UF.html#2115" class="Datatype">ℕ</a>

  <a id="f"></a><a id="2162" href="Cubical.Experiments.HoTT-UF.html#2162" class="Function">f</a> <a id="g"></a><a id="2164" href="Cubical.Experiments.HoTT-UF.html#2164" class="Function">g</a> <a id="2166" class="Symbol">:</a> <a id="2168" href="Cubical.Experiments.HoTT-UF.html#2115" class="Datatype">ℕ</a> <a id="2170" class="Symbol">→</a> <a id="2172" href="Cubical.Experiments.HoTT-UF.html#2115" class="Datatype">ℕ</a>

  <a id="2177" href="Cubical.Experiments.HoTT-UF.html#2162" class="Function">f</a> <a id="2179" href="Cubical.Experiments.HoTT-UF.html#2179" class="Bound">n</a> <a id="2181" class="Symbol">=</a> <a id="2183" href="Cubical.Experiments.HoTT-UF.html#2179" class="Bound">n</a>

  <a id="2188" href="Cubical.Experiments.HoTT-UF.html#2164" class="Function">g</a> <a id="2190" href="Cubical.Experiments.HoTT-UF.html#2134" class="InductiveConstructor">zero</a> <a id="2195" class="Symbol">=</a> <a id="2197" href="Cubical.Experiments.HoTT-UF.html#2134" class="InductiveConstructor">zero</a>
  <a id="2204" href="Cubical.Experiments.HoTT-UF.html#2164" class="Function">g</a> <a id="2206" class="Symbol">(</a><a id="2207" href="Cubical.Experiments.HoTT-UF.html#2146" class="InductiveConstructor">succ</a> <a id="2212" href="Cubical.Experiments.HoTT-UF.html#2212" class="Bound">n</a><a id="2213" class="Symbol">)</a> <a id="2215" class="Symbol">=</a> <a id="2217" href="Cubical.Experiments.HoTT-UF.html#2146" class="InductiveConstructor">succ</a> <a id="2222" class="Symbol">(</a><a id="2223" href="Cubical.Experiments.HoTT-UF.html#2164" class="Function">g</a> <a id="2225" href="Cubical.Experiments.HoTT-UF.html#2212" class="Bound">n</a><a id="2226" class="Symbol">)</a>

  <a id="h"></a><a id="2231" href="Cubical.Experiments.HoTT-UF.html#2231" class="Function">h</a> <a id="2233" class="Symbol">:</a> <a id="2235" class="Symbol">(</a><a id="2236" href="Cubical.Experiments.HoTT-UF.html#2236" class="Bound">n</a> <a id="2238" class="Symbol">:</a> <a id="2240" href="Cubical.Experiments.HoTT-UF.html#2115" class="Datatype">ℕ</a><a id="2241" class="Symbol">)</a> <a id="2243" class="Symbol">→</a> <a id="2245" href="Cubical.Experiments.HoTT-UF.html#2162" class="Function">f</a> <a id="2247" href="Cubical.Experiments.HoTT-UF.html#2236" class="Bound">n</a> <a id="2249" href="Cubical.Core.Id.html#1053" class="Function Operator">≡</a> <a id="2251" href="Cubical.Experiments.HoTT-UF.html#2164" class="Function">g</a> <a id="2253" href="Cubical.Experiments.HoTT-UF.html#2236" class="Bound">n</a>
  <a id="2257" href="Cubical.Experiments.HoTT-UF.html#2231" class="Function">h</a> <a id="2259" href="Cubical.Experiments.HoTT-UF.html#2134" class="InductiveConstructor">zero</a> <a id="2264" class="Symbol">=</a> <a id="2266" href="Cubical.Foundations.Id.html#2078" class="Function">refl</a>
  <a id="2273" href="Cubical.Experiments.HoTT-UF.html#2231" class="Function">h</a> <a id="2275" class="Symbol">(</a><a id="2276" href="Cubical.Experiments.HoTT-UF.html#2146" class="InductiveConstructor">succ</a> <a id="2281" href="Cubical.Experiments.HoTT-UF.html#2281" class="Bound">n</a><a id="2282" class="Symbol">)</a> <a id="2284" class="Symbol">=</a> <a id="2286" href="Cubical.Foundations.Id.html#2861" class="Function">ap</a> <a id="2289" href="Cubical.Experiments.HoTT-UF.html#2146" class="InductiveConstructor">succ</a> <a id="2294" class="Symbol">(</a><a id="2295" href="Cubical.Experiments.HoTT-UF.html#2231" class="Function">h</a> <a id="2297" href="Cubical.Experiments.HoTT-UF.html#2281" class="Bound">n</a><a id="2298" class="Symbol">)</a>

  <a id="p"></a><a id="2303" href="Cubical.Experiments.HoTT-UF.html#2303" class="Function">p</a> <a id="2305" class="Symbol">:</a> <a id="2307" href="Cubical.Experiments.HoTT-UF.html#2162" class="Function">f</a> <a id="2309" href="Cubical.Core.Id.html#1053" class="Function Operator">≡</a> <a id="2311" href="Cubical.Experiments.HoTT-UF.html#2164" class="Function">g</a>
  <a id="2315" href="Cubical.Experiments.HoTT-UF.html#2303" class="Function">p</a> <a id="2317" class="Symbol">=</a> <a id="2319" href="Cubical.Foundations.Id.html#4090" class="Function">funExt</a> <a id="2326" href="Cubical.Experiments.HoTT-UF.html#2231" class="Function">h</a>

  <a id="five"></a><a id="2331" href="Cubical.Experiments.HoTT-UF.html#2331" class="Function">five</a> <a id="2336" class="Symbol">:</a> <a id="2338" href="Cubical.Experiments.HoTT-UF.html#2115" class="Datatype">ℕ</a>
  <a id="2342" href="Cubical.Experiments.HoTT-UF.html#2331" class="Function">five</a> <a id="2347" class="Symbol">=</a> <a id="2349" href="Cubical.Experiments.HoTT-UF.html#2146" class="InductiveConstructor">succ</a> <a id="2354" class="Symbol">(</a><a id="2355" href="Cubical.Experiments.HoTT-UF.html#2146" class="InductiveConstructor">succ</a> <a id="2360" class="Symbol">(</a><a id="2361" href="Cubical.Experiments.HoTT-UF.html#2146" class="InductiveConstructor">succ</a> <a id="2366" class="Symbol">(</a><a id="2367" href="Cubical.Experiments.HoTT-UF.html#2146" class="InductiveConstructor">succ</a> <a id="2372" class="Symbol">(</a><a id="2373" href="Cubical.Experiments.HoTT-UF.html#2146" class="InductiveConstructor">succ</a> <a id="2378" href="Cubical.Experiments.HoTT-UF.html#2134" class="InductiveConstructor">zero</a><a id="2382" class="Symbol">))))</a>

  <a id="a"></a><a id="2390" href="Cubical.Experiments.HoTT-UF.html#2390" class="Function">a</a> <a id="2392" class="Symbol">:</a> <a id="2394" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a> <a id="2396" href="Cubical.Experiments.HoTT-UF.html#2115" class="Datatype">ℕ</a> <a id="2398" class="Symbol">(λ</a> <a id="2401" href="Cubical.Experiments.HoTT-UF.html#2401" class="Bound">n</a> <a id="2403" class="Symbol">→</a> <a id="2405" href="Cubical.Experiments.HoTT-UF.html#2162" class="Function">f</a> <a id="2407" href="Cubical.Experiments.HoTT-UF.html#2401" class="Bound">n</a> <a id="2409" href="Cubical.Core.Id.html#1053" class="Function Operator">≡</a> <a id="2411" href="Cubical.Experiments.HoTT-UF.html#2331" class="Function">five</a><a id="2415" class="Symbol">)</a>
  <a id="2419" href="Cubical.Experiments.HoTT-UF.html#2390" class="Function">a</a> <a id="2421" class="Symbol">=</a> <a id="2423" href="Cubical.Experiments.HoTT-UF.html#2331" class="Function">five</a> <a id="2428" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2430" href="Cubical.Foundations.Id.html#2078" class="Function">refl</a>

  <a id="b"></a><a id="2438" href="Cubical.Experiments.HoTT-UF.html#2438" class="Function">b</a> <a id="2440" class="Symbol">:</a> <a id="2442" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a> <a id="2444" href="Cubical.Experiments.HoTT-UF.html#2115" class="Datatype">ℕ</a> <a id="2446" class="Symbol">(λ</a> <a id="2449" href="Cubical.Experiments.HoTT-UF.html#2449" class="Bound">n</a> <a id="2451" class="Symbol">→</a> <a id="2453" href="Cubical.Experiments.HoTT-UF.html#2164" class="Function">g</a> <a id="2455" href="Cubical.Experiments.HoTT-UF.html#2449" class="Bound">n</a> <a id="2457" href="Cubical.Core.Id.html#1053" class="Function Operator">≡</a> <a id="2459" href="Cubical.Experiments.HoTT-UF.html#2331" class="Function">five</a><a id="2463" class="Symbol">)</a>
  <a id="2467" href="Cubical.Experiments.HoTT-UF.html#2438" class="Function">b</a> <a id="2469" class="Symbol">=</a> <a id="2471" href="Cubical.Foundations.Id.html#2671" class="Function">transport</a> <a id="2481" class="Symbol">(λ</a> <a id="2484" href="Cubical.Experiments.HoTT-UF.html#2484" class="Bound">-</a> <a id="2486" class="Symbol">→</a> <a id="2488" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a> <a id="2490" href="Cubical.Experiments.HoTT-UF.html#2115" class="Datatype">ℕ</a> <a id="2492" class="Symbol">(λ</a> <a id="2495" href="Cubical.Experiments.HoTT-UF.html#2495" class="Bound">n</a> <a id="2497" class="Symbol">→</a> <a id="2499" href="Cubical.Experiments.HoTT-UF.html#2484" class="Bound">-</a> <a id="2501" href="Cubical.Experiments.HoTT-UF.html#2495" class="Bound">n</a> <a id="2503" href="Cubical.Core.Id.html#1053" class="Function Operator">≡</a> <a id="2505" href="Cubical.Experiments.HoTT-UF.html#2331" class="Function">five</a><a id="2509" class="Symbol">))</a> <a id="2512" href="Cubical.Experiments.HoTT-UF.html#2303" class="Function">p</a> <a id="2514" href="Cubical.Experiments.HoTT-UF.html#2390" class="Function">a</a>

  <a id="c"></a><a id="2519" href="Cubical.Experiments.HoTT-UF.html#2519" class="Function">c</a> <a id="2521" class="Symbol">:</a> <a id="2523" href="Cubical.Foundations.Id.html#955" class="Field">pr₁</a> <a id="2527" href="Cubical.Experiments.HoTT-UF.html#2438" class="Function">b</a> <a id="2529" href="Cubical.Core.Id.html#1053" class="Function Operator">≡</a> <a id="2531" href="Cubical.Experiments.HoTT-UF.html#2331" class="Function">five</a>
  <a id="2538" href="Cubical.Experiments.HoTT-UF.html#2519" class="Function">c</a> <a id="2540" class="Symbol">=</a> <a id="2542" href="Cubical.Foundations.Id.html#2078" class="Function">refl</a>

<a id="2548" class="Comment">{-

If we had funExt as a postulate, then the definition of c would not
type check. Moreover, the term pr₁ b would not evaluate to five, as it
does with the cubical type theory implementation of funext.

TODO. A similar computational example with univalence.

-}</a>
</pre></body></html>